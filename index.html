<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Push Swap Visualizer</title>
    <style>
        :root {
            --bg-color: #1a1d24;
            --panel-bg: #23272e;
            --text-color: #e2e8f0;
            --accent-color: #8a85ff;
            --success-color: #4ade80;
            --button-color: #2f3541;
            --button-hover: #3a4150;
            --slider-bg: #4b5563;
            --slider-thumb: #8a85ff;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        header {
            padding: 1rem;
            background-color: var(--panel-bg);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent-color);
        }
        
        .main-container {
            display: flex;
            flex: 1;
        }
        
        .sidebar {
            width: 320px;
            background-color: var(--panel-bg);
            padding: 1rem;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        
        .panel-title {
            font-size: 1rem;
            text-transform: uppercase;
            margin-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 0.5rem;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .panel {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        
        .tab-buttons {
            display: flex;
            margin-bottom: 1rem;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .tab-button {
            flex: 1;
            padding: 0.75rem;
            border: none;
            background-color: var(--button-color);
            color: var(--text-color);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .tab-button.active {
            background-color: var(--accent-color);
            color: white;
        }
        
        .tab-button:hover:not(.active) {
            background-color: var(--button-hover);
        }
        
        label {
            display: block;
            margin-bottom: 0.5rem;
            color: rgba(255, 255, 255, 0.8);
        }
        
        textarea, input[type="text"], input[type="number"] {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            background-color: rgba(0, 0, 0, 0.2);
            color: var(--text-color);
            font-size: 0.9rem;
            resize: vertical;
            margin-bottom: 1rem;
        }
        
        button {
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 4px;
            background-color: var(--accent-color);
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
            font-weight: 600;
        }
        
        button:hover {
            background-color: #7a75ef;
        }
        
        button.secondary {
            background-color: var(--button-color);
        }
        
        button.secondary:hover {
            background-color: var(--button-hover);
        }
        
        .button-group {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .main-content {
            flex: 1;
            padding: 1rem;
            display: flex;
            flex-direction: column;
        }
        
        .sequence-panel {
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            display: flex;
            flex-direction: column;
        }
        
        .sequence-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .sequence-title {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .sequence-stats {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .sequence-status {
            color: var(--success-color);
            font-weight: 600;
        }
        
        .sequence-operations {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            padding: 1rem;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            min-height: 60px;
            overflow-y: auto;
            max-height: 120px;
        }
        
        .operation {
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            background-color: var(--button-color);
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .operation.highlighted {
            background-color: var(--accent-color);
            color: white;
        }
        
        .visualization-panel {
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 1rem;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .visualization-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .stacks-info {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .view-toggle {
            display: flex;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .view-toggle button {
            padding: 0.5rem 1rem;
            border: none;
            background-color: var(--button-color);
            color: var(--text-color);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .view-toggle button.active {
            background-color: var(--accent-color);
            color: white;
        }
        
        .view-toggle button:hover:not(.active) {
            background-color: var(--button-hover);
        }
        
        .visualization-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        canvas {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .control-panel {
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }
        
        .control-buttons {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .slider-label {
            min-width: 160px;
            text-align: right;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 5px;
            background: var(--slider-bg);
            outline: none;
            border-radius: 5px;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: var(--slider-thumb);
            cursor: pointer;
        }
        
        .slider::-moz-range-thumb {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: var(--slider-thumb);
            cursor: pointer;
        }
        
        .step-controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .step-button {
            background-color: var(--button-color);
            color: var(--text-color);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
        }
        
        .step-button:hover {
            background-color: var(--button-hover);
        }
        
        .play-button {
            width: 50px;
            height: 50px;
        }
        
        /* Custom styling for the bars */
        .bar-horizontal {
            position: absolute;
            background: linear-gradient(to right, #a78bfa, #8b5cf6);
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        
        .bar-vertical {
            position: absolute;
            background: linear-gradient(to top, #a78bfa, #8b5cf6);
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        
        .stack-a .bar-horizontal, .stack-a .bar-vertical {
            background: linear-gradient(90deg, #4ade80, #22c55e);
        }
        
        .stack-b .bar-horizontal, .stack-b .bar-vertical {
            background: linear-gradient(90deg, #60a5fa, #3b82f6);
        }
    </style>
</head>
<body>
    <header>
        <div class="logo">Push Swap Visualizer</div>
    </header>
    
    <div class="main-container">
        <div class="sidebar">
            <div>
                <h2 class="panel-title">Program</h2>
                <div class="panel">
                    <div class="tab-buttons">
                        <button class="tab-button active" id="manual-tab">Manual</button>
                        <button class="tab-button" id="auto-tab">Auto-detect</button>
                    </div>
                    <div id="manual-content">
                        <label for="numbers">Values (space-separated)</label>
                        <textarea id="numbers" rows="4">18 21 23 25 3 17 29 10 15 20 33 9 40 36 32 6 0 19 31 38 1 35 16 26 30 28 5 27 12 22 34 41 4 24 8 11 39 13 7 2 37 14</textarea>
                        
                        <div style="margin: 1rem 0; padding: 0.75rem; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; background-color: rgba(0, 0, 0, 0.2);">
                            <label style="margin-bottom: 0.5rem; display: block;">Command to execute:</label>
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <code id="command-display" style="font-family: monospace; background-color: rgba(0, 0, 0, 0.3); padding: 0.5rem; border-radius: 4px; overflow-x: auto; flex-grow: 1; white-space: nowrap;"># Command will appear here</code>
                                <button id="copy-btn" style="margin-left: 0.5rem; padding: 0.5rem; min-width: 80px;" class="secondary">Copy</button>
                            </div>
                        </div>
                        
                        <label for="operations">Operations (one per line)</label>
                        <textarea id="operations" rows="6"></textarea>
                        
                        <div class="button-group">
                            <button id="load-btn">Load</button>
                            <button id="clear-btn" class="secondary">Clear</button>
                            <button id="import-txt-btn" class="secondary">Import TXT</button>
                        </div>
                        <input type="file" id="operation-file" accept=".txt" style="display: none;">
                        <div>
                            <label for="count">Count</label>
                            <div style="display: flex; gap: 0.5rem;">
                                <input type="number" id="count" value="42" min="1" max="500">
                                <button id="shuffle-btn" class="secondary">Shuffle</button>
                            </div>
                        </div>
                    </div>
                    <div id="auto-content" style="display: none;">
                        <p style="margin-bottom: 1rem;">Run your push_swap program and paste its output here:</p>
                        <textarea id="auto-operations" rows="8" placeholder="pa
pb
ra
...">
</textarea>
                        <div class="button-group">
                            <button id="auto-load-btn">Load Operations</button>
                            <button id="auto-import-txt-btn" class="secondary">Import TXT</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div>
                <h2 class="panel-title">Statistics</h2>
                <div class="panel">
                    <div id="stats-content" style="font-size: 0.9rem; line-height: 1.6;">
                        <div><strong>Total operations:</strong> <span id="total-ops">0</span></div>
                        <div><strong>Current step:</strong> <span id="current-step">0</span>/<span id="max-steps">0</span></div>
                        <div style="margin-top: 1rem;">
                            <strong>Operation breakdown:</strong>
                            <ul id="op-breakdown" style="list-style: none; margin-top: 0.5rem;">
                                <li><strong>sa:</strong> <span id="sa-count">0</span> (0%)</li>
                                <li><strong>sb:</strong> <span id="sb-count">0</span> (0%)</li>
                                <li><strong>ss:</strong> <span id="ss-count">0</span> (0%)</li>
                                <li><strong>pa:</strong> <span id="pa-count">0</span> (0%)</li>
                                <li><strong>pb:</strong> <span id="pb-count">0</span> (0%)</li>
                                <li><strong>ra:</strong> <span id="ra-count">0</span> (0%)</li>
                                <li><strong>rb:</strong> <span id="rb-count">0</span> (0%)</li>
                                <li><strong>rr:</strong> <span id="rr-count">0</span> (0%)</li>
                                <li><strong>rra:</strong> <span id="rra-count">0</span> (0%)</li>
                                <li><strong>rrb:</strong> <span id="rrb-count">0</span> (0%)</li>
                                <li><strong>rrr:</strong> <span id="rrr-count">0</span> (0%)</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="sequence-panel">
                <div class="sequence-header">
                    <div class="sequence-title">Operations Sequence</div>
                    <div class="sequence-stats">
                        <span id="op-count">0</span> operations
                        <span class="sequence-status" id="status"></span>
                    </div>
                </div>
                <div class="sequence-operations" id="operations-display"></div>
            </div>
            
            <div class="visualization-panel">
                <div class="visualization-header">
                    <div class="stacks-info">
                        Stack A: <span id="stack-a-count">0</span> elements | 
                        Stack B: <span id="stack-b-count">0</span> elements
                    </div>
                </div>
                <div class="visualization-container">
                    <canvas id="visualization-canvas"></canvas>
                </div>
            </div>
            
            <div class="control-panel">
                <div class="control-buttons">
                    <button id="reset-btn">Reset</button>
                    <button id="start-btn">Start</button>
                    <button id="pause-btn" disabled>Pause</button>
                </div>
                <div class="slider-container">
                    <div class="slider-label"><span id="speed-value">20</span> moves per second</div>
                    <input type="range" min="1" max="100" value="20" class="slider" id="speed-slider">
                </div>
                <div class="step-controls">
                    <button class="step-button" id="step-start">⏮</button>
                    <button class="step-button" id="step-prev">◀</button>
                    <button class="step-button play-button" id="play-pause">▶</button>
                    <button class="step-button" id="step-next">▶</button>
                    <button class="step-button" id="step-end">⏭</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Configuration
        const config = {
            animationSpeed: 20, // operations per second
            viewMode: 'horizontal',
            isPlaying: false,
            colorPalette: {
                stackA: ['#4ade80', '#22c55e'],
                stackB: ['#60a5fa', '#3b82f6']
            }
        };
        
        // State
        let stackA = [];
        let stackB = [];
        let operations = [];
        let currentStep = -1;
        let animationTimer = null;
        
        // DOM Elements
        const canvas = document.getElementById('visualization-canvas');
        const ctx = canvas.getContext('2d');
        
        const numbersInput = document.getElementById('numbers');
        const operationsInput = document.getElementById('operations');
        const autoOperationsInput = document.getElementById('auto-operations');
        const countInput = document.getElementById('count');
        
        const loadBtn = document.getElementById('load-btn');
        const clearBtn = document.getElementById('clear-btn');
        const shuffleBtn = document.getElementById('shuffle-btn');
        const autoLoadBtn = document.getElementById('auto-load-btn');
        
        const manualTab = document.getElementById('manual-tab');
        const autoTab = document.getElementById('auto-tab');
        const manualContent = document.getElementById('manual-content');
        const autoContent = document.getElementById('auto-content');
        
        const resetBtn = document.getElementById('reset-btn');
        const startBtn = document.getElementById('start-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const playPauseBtn = document.getElementById('play-pause');
        
        const stepStartBtn = document.getElementById('step-start');
        const stepPrevBtn = document.getElementById('step-prev');
        const stepNextBtn = document.getElementById('step-next');
        const stepEndBtn = document.getElementById('step-end');
        
        const speedSlider = document.getElementById('speed-slider');
        const speedValue = document.getElementById('speed-value');
        
        const operationsDisplay = document.getElementById('operations-display');
        const opCount = document.getElementById('op-count');
        const statusDisplay = document.getElementById('status');
        
        const stackACount = document.getElementById('stack-a-count');
        const stackBCount = document.getElementById('stack-b-count');
        
        const totalOps = document.getElementById('total-ops');
        const currentStepDisplay = document.getElementById('current-step');
        const maxStepsDisplay = document.getElementById('max-steps');
        const commandDisplay = document.getElementById('command-display');
        const copyBtn = document.getElementById('copy-btn');

        const importTxtBtn = document.getElementById('import-txt-btn');
        const operationFile = document.getElementById('operation-file');

        const autoImportTxtBtn = document.getElementById('auto-import-txt-btn');
        
        // Operation count elements
        const opBreakdown = {
            sa: document.getElementById('sa-count'),
            sb: document.getElementById('sb-count'),
            ss: document.getElementById('ss-count'),
            pa: document.getElementById('pa-count'),
            pb: document.getElementById('pb-count'),
            ra: document.getElementById('ra-count'),
            rb: document.getElementById('rb-count'),
            rr: document.getElementById('rr-count'),
            rra: document.getElementById('rra-count'),
            rrb: document.getElementById('rrb-count'),
            rrr: document.getElementById('rrr-count')
        };
        
        // Initialize
        function init() {
            // Resize canvas for high DPI displays
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Set up event listeners
            loadBtn.addEventListener('click', loadData);
            clearBtn.addEventListener('click', clearData);
            shuffleBtn.addEventListener('click', shuffleNumbers);
            autoLoadBtn.addEventListener('click', loadAutoData);
            copyBtn.addEventListener('click', copyCommand);
            
            manualTab.addEventListener('click', () => switchTab('manual'));
            autoTab.addEventListener('click', () => switchTab('auto'));
            
            resetBtn.addEventListener('click', resetVisualization);
            startBtn.addEventListener('click', startAnimation);
            pauseBtn.addEventListener('click', pauseAnimation);
            playPauseBtn.addEventListener('click', togglePlayPause);
            
            stepStartBtn.addEventListener('click', () => goToStep(0));
            stepPrevBtn.addEventListener('click', () => goToStep(currentStep - 1));
            stepNextBtn.addEventListener('click', () => goToStep(currentStep + 1));
            stepEndBtn.addEventListener('click', () => goToStep(operations.length));
            
            speedSlider.addEventListener('input', updateSpeed);
            
            // Add event listener for the numbers input to update the command
            numbersInput.addEventListener('input', updateCommandDisplay);

            // Add event import button
            // Configuration du bouton Import TXT
            importTxtBtn.addEventListener('click', () => operationFile.click());
            operationFile.addEventListener('change', e => {
                if (manualTab.classList.contains('active')) {
                    handleFileImport(e);
                } else if (autoTab.classList.contains('active')) {
                    handleAutoFileImport(e);
                }
            });

            // Configuration drag-and-drop
            importTxtBtn.addEventListener('dragover', e => {
                e.preventDefault();
                e.stopPropagation();
                importTxtBtn.style.backgroundColor = '#7a75ef';
            });

            importTxtBtn.addEventListener('dragleave', e => {
                e.preventDefault();
                e.stopPropagation();
                importTxtBtn.style.backgroundColor = '';
            });

            importTxtBtn.addEventListener('drop', handleDrop);

            // Configuration du bouton Import TXT dans l'onglet Auto-detect
            autoImportTxtBtn.addEventListener('click', () => operationFile.click());

            // Configuration drag-and-drop pour l'onglet Auto-detect
            autoImportTxtBtn.addEventListener('dragover', e => {
                e.preventDefault();
                e.stopPropagation();
                autoImportTxtBtn.style.backgroundColor = '#7a75ef';
            });

            autoImportTxtBtn.addEventListener('dragleave', e => {
                e.preventDefault();
                e.stopPropagation();
                autoImportTxtBtn.style.backgroundColor = '';
            });

            autoImportTxtBtn.addEventListener('drop', handleAutoImportDrop);
            
            // Load example data
            loadData();
        }

        // Gestion du drop
        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            importTxtBtn.style.backgroundColor = '';

            const files = e.dataTransfer.files;
            if (files.length > 0 && (files[0].type === 'text/plain' || files[0].name.endsWith('.txt'))) {
                handleFileImport({ files: files });
            } else {
                alert('Please drop a text (.txt) file.');
            }
        }

        // Fonction pour gérer l'importation de fichier
        function handleFileImport(event) {
            const file = event.files ? event.files[0] : event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;

                // Parse operations from file
                const fileOperations = content.split(/\s+|\n+/).filter(op => op.trim());

                // Check if any valid operations were found
                if (fileOperations.length === 0) {
                    alert('No valid operations found in the file.');
                    return;
                }

                // Set the operations in the operations textarea
                operationsInput.value = fileOperations.join('\n');

                // Auto-load the operations
                loadData();
            };

            reader.onerror = function() {
                alert('Error reading file.');
            };

            reader.readAsText(file);
        }

        // Gestion du drop pour l'onglet Auto-detect
        function handleAutoImportDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            autoImportTxtBtn.style.backgroundColor = '';

            const files = e.dataTransfer.files;
            if (files.length > 0 && (files[0].type === 'text/plain' || files[0].name.endsWith('.txt'))) {
                handleAutoFileImport({ files: files });
            } else {
                alert('Please drop a text (.txt) file.');
            }
        }

        // Fonction pour gérer l'importation de fichier dans l'onglet Auto-detect
        function handleAutoFileImport(event) {
            const file = event.files ? event.files[0] : event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;

                // Parse operations from file
                const fileOperations = content.split(/\s+|\n+/).filter(op => op.trim());

                // Check if any valid operations were found
                if (fileOperations.length === 0) {
                    alert('No valid operations found in the file.');
                    return;
                }

                // Set the operations in the auto-operations textarea
                autoOperationsInput.value = fileOperations.join('\n');

                // Optional: Auto-load the operations
                loadAutoData();
            };

            reader.onerror = function() {
                alert('Error reading file.');
            };

            reader.readAsText(file);
        }
        
        // Resize canvas for high DPI displays
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            ctx.scale(dpr, dpr);
            
            draw();
        }
        
        // Switch between manual and auto-detect tabs
        function switchTab(tab) {
            if (tab === 'manual') {
                manualTab.classList.add('active');
                autoTab.classList.remove('active');
                manualContent.style.display = 'block';
                autoContent.style.display = 'none';
            } else {
                manualTab.classList.remove('active');
                autoTab.classList.add('active');
                manualContent.style.display = 'none';
                autoContent.style.display = 'block';
            }
        }
        
        // Update command display
        function updateCommandDisplay() {
            const numbersStr = numbersInput.value.trim();
            if (numbersStr) {
                commandDisplay.textContent = `./push_swap ${numbersStr} > log.txt`;
            } else {
                commandDisplay.textContent = "# Command will appear here";
            }
        }
        /*
        // Copy command to clipboard
        function copyCommand() {
            const command = commandDisplay.textContent;
            if (command && command !== "# Command will appear here") {
                navigator.clipboard.writeText(command)
                    .then(() => {
                        // Visual feedback for copy
                        const originalText = copyBtn.textContent;
                        copyBtn.textContent = "Copied!";
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                        }, 2000);
                    })
                    .catch(err => {
                        console.error('Could not copy text: ', err);
                        alert('Failed to copy to clipboard. Please copy manually.');
                    });
            }
        }
        */

        function copyCommand() {
            const command = commandDisplay.textContent;
            if (command && command !== "# Command will appear here") {
                // Créer un élément temporaire
                const tempElement = document.createElement('textarea');
                tempElement.value = command;
                document.body.appendChild(tempElement);
                tempElement.select();
                
                try {
                    const success = document.execCommand('copy');
                    if (success) {
                        // Visual feedback for copy
                        const originalText = copyBtn.textContent;
                        copyBtn.textContent = "Copied!";
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                        }, 2000);
                    } else {
                        alert('Failed to copy to clipboard. Please copy manually.');
                    }
                } catch (err) {
                    console.error('Could not copy text: ', err);
                    alert('Failed to copy to clipboard. Please copy manually.');
                }
                
                // Nettoyer
                document.body.removeChild(tempElement);
            }
        }
        
        // Load data from inputs
        function loadData() {
            const numbersStr = numbersInput.value.trim();
            const operationsStr = operationsInput.value.trim();
            
            if (!numbersStr) {
                alert('Please enter some numbers.');
                return;
            }
            
            // Parse numbers
            const numbers = numbersStr.split(/\s+/).map(n => parseInt(n, 10));
            
            // Check for invalid numbers
            if (numbers.some(isNaN)) {
                alert('Invalid numbers found. Please enter valid integers.');
                return;
            }
            
            // Initialize stacks
            stackA = [...numbers];
            stackB = [];
            
            // Parse operations
            operations = operationsStr ? operationsStr.split(/\s+|\n+/).filter(op => op.trim()) : [];
            
            // Reset current step
            currentStep = -1;
            
            // Update UI
            updateOperationsDisplay();
            updateStats();
            updateCommandDisplay();
            statusDisplay.textContent = '';
            
            // Redraw
            draw();
        }
        
        // Load data from auto-detect tab
        function loadAutoData() {
            const operationsStr = autoOperationsInput.value.trim();
            
            if (!operationsStr) {
                alert('Please paste the output from your push_swap program.');
                return;
            }
            
            // Parse operations
            operations = operationsStr.split(/\s+|\n+/).filter(op => op.trim());
            
            // Check if any valid operations were found
            if (operations.length === 0) {
                alert('No valid operations found.');
                return;
            }
            
            // Use the current numbers or generate random ones if none
            if (stackA.length === 0) {
                const count = parseInt(countInput.value, 10) || 10;
                generateRandomNumbers(count);
            }
            
            // Reset current step
            currentStep = -1;
            
            // Update UI
            updateOperationsDisplay();
            updateStats();
            statusDisplay.textContent = '';
            
            // Redraw
            draw();
        }
        
        // Clear input data
        function clearData() {
            numbersInput.value = '';
            operationsInput.value = '';
            autoOperationsInput.value = '';
            stackA = [];
            stackB = [];
            operations = [];
            currentStep = -1;
            
            updateOperationsDisplay();
            updateStats();
            updateCommandDisplay(); // Update the command display
            statusDisplay.textContent = '';
            
            draw();
        }
        
        // Generate random numbers and shuffle them
        function shuffleNumbers() {
            const count = parseInt(countInput.value, 10) || 10;
            generateRandomNumbers(count);
            
            // Update numbers input
            numbersInput.value = stackA.join(' ');
            
            // Reset operations
            operations = [];
            operationsInput.value = '';
            autoOperationsInput.value = '';
            currentStep = -1;
            
            updateOperationsDisplay();
            updateStats();
			updateCommandDisplay(); // Update the command display
            statusDisplay.textContent = '';
            
            draw();
        }
        
        // Generate random numbers
        function generateRandomNumbers(count) {
            // Generate sequential numbers
            const numbers = Array.from({ length: count }, (_, i) => i + 1);
            
            // Shuffle using Fisher-Yates algorithm
            for (let i = numbers.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [numbers[i], numbers[j]] = [numbers[j], numbers[i]];
            }
            
            stackA = numbers;
            stackB = [];
            
            // Update the command display
            updateCommandDisplay();
        }
        
        // Update operations display
        function updateOperationsDisplay() {
            operationsDisplay.innerHTML = '';
            
            operations.forEach((op, index) => {
                const opElement = document.createElement('div');
                opElement.textContent = op;
                opElement.classList.add('operation');
                
                if (index <= currentStep) {
                    opElement.classList.add('highlighted');
                }
                
                operationsDisplay.appendChild(opElement);
            });
            
            // Scroll to the current operation
            if (currentStep >= 0 && currentStep < operations.length) {
                const highlightedOps = operationsDisplay.querySelectorAll('.highlighted');
                if (highlightedOps.length > 0) {
                    const lastHighlighted = highlightedOps[highlightedOps.length - 1];
                    lastHighlighted.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }
            
            opCount.textContent = operations.length;
        }
        
        // Update statistics
        function updateStats() {
            // Count operations by type
            const counts = {
                sa: 0, sb: 0, ss: 0,
                pa: 0, pb: 0,
                ra: 0, rb: 0, rr: 0,
                rra: 0, rrb: 0, rrr: 0
            };
            
            operations.forEach(op => {
                if (counts[op] !== undefined) {
                    counts[op]++;
                }
            });
            
            // Update counts in UI
            for (const [op, count] of Object.entries(counts)) {
                if (opBreakdown[op]) {
                    const percentage = operations.length > 0 ? ((count / operations.length) * 100).toFixed(1) : '0';
                    opBreakdown[op].textContent = `${count} (${percentage}%)`;
                }
            }
            
            // Update total operations
            totalOps.textContent = operations.length;
            maxStepsDisplay.textContent = operations.length;
            currentStepDisplay.textContent = currentStep + 1;
            
            // Update stack counts
            stackACount.textContent = stackA.length;
            stackBCount.textContent = stackB.length;
            
            // Check if the stack is sorted
            if (isSorted(stackA) && stackB.length === 0) {
                statusDisplay.textContent = '[OK]';
                statusDisplay.style.color = 'var(--success-color)';
            } else if (currentStep >= operations.length - 1 && operations.length > 0) {
                statusDisplay.textContent = '[KO]';
                statusDisplay.style.color = '#ef4444';
            } else {
                statusDisplay.textContent = '';
            }
        }
        
        // Check if an array is sorted
        function isSorted(arr) {
            if (arr.length <= 1) return true;
            
            for (let i = 1; i < arr.length; i++) {
                if (arr[i] < arr[i-1]) return false;
            }
            
            return true;
        }
        
        // Reset visualization
        function resetVisualization() {
            // Stop animation if running
            if (animationTimer) {
                clearTimeout(animationTimer);
                animationTimer = null;
            }
            
            // Reset stacks to initial state
            const initialNumbers = numbersInput.value.trim().split(/\s+/).map(n => parseInt(n, 10));
            if (initialNumbers.some(isNaN)) {
                alert('Invalid numbers in the input field.');
                return;
            }
            
            stackA = [...initialNumbers];
            stackB = [];
            currentStep = -1;
            
            // Update UI
            updateOperationsDisplay();
            updateStats();
            
            // Reset animation controls
            config.isPlaying = false;
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            playPauseBtn.textContent = '▶';
            
            // Redraw
            draw();
        }
        
        // Start animation
        function startAnimation() {
            if (operations.length === 0) {
                alert('No operations to animate.');
                return;
            }
            
            config.isPlaying = true;
            startBtn.disabled = true;
            pauseBtn.disabled = false;
            playPauseBtn.textContent = '⏸';
            
            animateNextStep();
        }
        
        // Pause animation
        function pauseAnimation() {
            config.isPlaying = false;
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            playPauseBtn.textContent = '▶';
            
            if (animationTimer) {
                clearTimeout(animationTimer);
                animationTimer = null;
            }
        }
        
        // Toggle play/pause
        function togglePlayPause() {
            if (config.isPlaying) {
                pauseAnimation();
            } else {
                startAnimation();
            }
        }
        
        // Go to a specific step
        function goToStep(step) {
            // Stop animation if running
            if (animationTimer) {
                clearTimeout(animationTimer);
                animationTimer = null;
                config.isPlaying = false;
                startBtn.disabled = false;
                pauseBtn.disabled = true;
                playPauseBtn.textContent = '▶';
            }
            
            // Validate step
            if (step < 0) step = 0;
            if (step > operations.length) step = operations.length;
            
            // Reset to initial state
            const initialNumbers = numbersInput.value.trim().split(/\s+/).map(n => parseInt(n, 10));
            if (initialNumbers.some(isNaN)) {
                alert('Invalid numbers in the input field.');
                return;
            }
            
            stackA = [...initialNumbers];
            stackB = [];
            
            // Execute operations up to the desired step
            for (let i = 0; i < step; i++) {
                executeOperation(operations[i]);
            }
            
            currentStep = step - 1;
            
            // Update UI
            updateOperationsDisplay();
            updateStats();
            
            // Redraw
            draw();
        }
        
        // Animate the next step
        function animateNextStep() {
            if (!config.isPlaying || currentStep >= operations.length - 1) {
                config.isPlaying = false;
                startBtn.disabled = false;
                pauseBtn.disabled = true;
                playPauseBtn.textContent = '▶';
                return;
            }
            
            // Execute the next operation
            currentStep++;
            executeOperation(operations[currentStep]);
            
            // Update UI
            updateOperationsDisplay();
            updateStats();
            draw();
            
            // Schedule the next step
            const delay = 1000 / config.animationSpeed;
            animationTimer = setTimeout(animateNextStep, delay);
        }
        
        // Execute a single operation
        function executeOperation(op) {
            switch (op) {
                case 'sa':
                    if (stackA.length >= 2) {
                        [stackA[0], stackA[1]] = [stackA[1], stackA[0]];
                    }
                    break;
                    
                case 'sb':
                    if (stackB.length >= 2) {
                        [stackB[0], stackB[1]] = [stackB[1], stackB[0]];
                    }
                    break;
                    
                case 'ss':
                    if (stackA.length >= 2) {
                        [stackA[0], stackA[1]] = [stackA[1], stackA[0]];
                    }
                    if (stackB.length >= 2) {
                        [stackB[0], stackB[1]] = [stackB[1], stackB[0]];
                    }
                    break;
                    
                case 'pa':
                    if (stackB.length > 0) {
                        stackA.unshift(stackB.shift());
                    }
                    break;
                    
                case 'pb':
                    if (stackA.length > 0) {
                        stackB.unshift(stackA.shift());
                    }
                    break;
                    
                case 'ra':
                    if (stackA.length > 0) {
                        stackA.push(stackA.shift());
                    }
                    break;
                    
                case 'rb':
                    if (stackB.length > 0) {
                        stackB.push(stackB.shift());
                    }
                    break;
                    
                case 'rr':
                    if (stackA.length > 0) {
                        stackA.push(stackA.shift());
                    }
                    if (stackB.length > 0) {
                        stackB.push(stackB.shift());
                    }
                    break;
                    
                case 'rra':
                    if (stackA.length > 0) {
                        stackA.unshift(stackA.pop());
                    }
                    break;
                    
                case 'rrb':
                    if (stackB.length > 0) {
                        stackB.unshift(stackB.pop());
                    }
                    break;
                    
                case 'rrr':
                    if (stackA.length > 0) {
                        stackA.unshift(stackA.pop());
                    }
                    if (stackB.length > 0) {
                        stackB.unshift(stackB.pop());
                    }
                    break;
                    
                default:
                    console.warn(`Unknown operation: ${op}`);
            }
        }
        
        // Update speed
        function updateSpeed() {
            config.animationSpeed = parseInt(speedSlider.value, 10);
            speedValue.textContent = config.animationSpeed;
        }
        
        // Draw the visualization
        function draw() {
            const rect = canvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Find max value for scaling
            const allValues = [...stackA, ...stackB];
            const maxValue = allValues.length > 0 ? Math.max(...allValues) : 1;
            
            drawVertical(width, height, maxValue);
        }
        
        // Draw horizontal view
        function drawHorizontal(width, height, maxValue) {
            // Calculate dimensions
            const padding = 40;
            const maxBarHeight = 20;
            const spacing = 5;
            
            // Find the max value for scaling
            const allNumbers = [...stackA, ...stackB];
            const max = allNumbers.length > 0 ? Math.max(...allNumbers) : 1;
            
            // Set up display areas
            const stackAWidth = width / 2 - padding * 2;
            const stackBWidth = width / 2 - padding * 2;
            
            // Draw stack info
            ctx.font = '16px sans-serif';
            ctx.fillStyle = 'var(--text-color)';
            ctx.textAlign = 'left';
            ctx.fillText(`Stack A = [${stackA.length}]`, padding, 30);
            ctx.fillText(`Stack B = [${stackB.length}]`, width / 2 + padding, 30);
            
            // Calculate dynamic spacing based on stack sizes
            const heightA = stackA.length > 0 ? (maxBarHeight + spacing) * stackA.length - spacing : 0;
            const heightB = stackB.length > 0 ? (maxBarHeight + spacing) * stackB.length - spacing : 0;
            const maxHeight = Math.max(heightA, heightB);
            
            const startYA = (height - maxHeight) / 2;
            const startYB = (height - maxHeight) / 2;
            
            // Create gradient colors for the stacks
            const gradientLength = 100; // Number of colors in the gradient
            const colorsA = createColorGradient('#8a85ff', '#60a5fa', gradientLength);
            const colorsB = createColorGradient('#22c55e', '#eab308', gradientLength);
            
            // Draw Stack A (horizontal bars)
            for (let i = 0; i < stackA.length; i++) {
                const value = stackA[i];
                const barWidth = (value / max) * stackAWidth;
                const y = startYA + i * (maxBarHeight + spacing);
                
                // Calculate color index based on value
                const colorIndex = Math.floor((value / max) * (gradientLength - 1));
                const color = colorsA[colorIndex];
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.rect(padding, y, barWidth, maxBarHeight);
                ctx.fill();
            }
            
            // Draw Stack B (horizontal bars)
            for (let i = 0; i < stackB.length; i++) {
                const value = stackB[i];
                const barWidth = (value / max) * stackBWidth;
                const y = startYB + i * (maxBarHeight + spacing);
                
                // Calculate color index based on value
                const colorIndex = Math.floor((value / max) * (gradientLength - 1));
                const color = colorsB[colorIndex];
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.rect(width / 2 + padding, y, barWidth, maxBarHeight);
                ctx.fill();
            }
        }
        
        // Draw vertical view
        function drawVertical(width, height, maxValue) {
            // Calculate dimensions
            const padding = 50;
            const maxBarWidth = 20;
            const spacing = 5;
            const bottomY = height - padding;
            
            // Find the max value for scaling
            const allNumbers = [...stackA, ...stackB];
            const max = allNumbers.length > 0 ? Math.max(...allNumbers) : 1;
            
            // Create gradient colors for the stacks
            const gradientLength = 100; // Number of colors in the gradient
            const colors = createColorGradient('#22c55e', '#8a85ff', gradientLength);
            
            // Calculate total width needed
            const totalWidth = (stackA.length + stackB.length) * (maxBarWidth + spacing) - spacing;
            const availableWidth = width - (padding * 2);
            const scale = totalWidth > availableWidth ? availableWidth / totalWidth : 1;
            
            // Adjust bar width and spacing if needed
            const barWidth = maxBarWidth * scale;
            const adjustedSpacing = spacing * scale;
            
            // Center the display
            const startX = (width - (totalWidth * scale)) / 2;
            
            // Draw stack info
            ctx.font = '16px sans-serif';
            ctx.fillStyle = 'var(--text-color)';
            ctx.textAlign = 'left';
            ctx.fillText(`Stack A = [${stackA.length}]`, 20, 30);
            ctx.fillText(`Stack B = [${stackB.length}]`, 20, 60);
            
            // Draw Stack A bars (left side of visualization)
            for (let i = 0; i < stackA.length; i++) {
                const value = stackA[i];
                const barHeight = (value / max) * (height - padding * 2);
                const x = startX + i * (barWidth + adjustedSpacing);
                
                // Calculate color index based on value
                const colorIndex = Math.floor((value / max) * (gradientLength - 1));
                const color = colors[colorIndex];
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.rect(x, bottomY - barHeight, barWidth, barHeight);
                ctx.fill();
            }
            
            // Draw a blue dot separator
            const separatorX = startX + stackA.length * (barWidth + adjustedSpacing) - adjustedSpacing / 2;
            ctx.fillStyle = '#60a5fa';
            ctx.beginPath();
            ctx.arc(separatorX, bottomY + 10, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw Stack B bars (right side of visualization)
            for (let i = 0; i < stackB.length; i++) {
                const value = stackB[i];
                const barHeight = (value / max) * (height - padding * 2);
                const x = startX + stackA.length * (barWidth + adjustedSpacing) + i * (barWidth + adjustedSpacing);
                
                // Calculate color index based on value
                const colorIndex = Math.floor((value / max) * (gradientLength - 1));
                const color = colors[colorIndex];
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.rect(x, bottomY - barHeight, barWidth, barHeight);
                ctx.fill();
            }
        }
        
        // Helper function to generate color gradient
        function createColorGradient(startColor, endColor, steps) {
            const result = [];
            
            // Parse the hex colors to RGB
            const startRGB = hexToRgb(startColor);
            const endRGB = hexToRgb(endColor);
            
            // Create gradient
            for (let i = 0; i < steps; i++) {
                const ratio = i / (steps - 1);
                const r = Math.round(startRGB.r + ratio * (endRGB.r - startRGB.r));
                const g = Math.round(startRGB.g + ratio * (endRGB.g - startRGB.g));
                const b = Math.round(startRGB.b + ratio * (endRGB.b - startRGB.b));
                
                result.push(`rgb(${r}, ${g}, ${b})`);
            }
            
            return result;
        }
        
        // Helper function to convert hex to RGB
        function hexToRgb(hex) {
            // Remove # if present
            hex = hex.replace(/^#/, '');
            
            // Parse hex
            const bigint = parseInt(hex, 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            
            return { r, g, b };
        }
        
        // Initialize the application
        window.addEventListener('load', init);
    </script>
</body>
</html>